# **O que é desenvolvimento front-end?**

**O desenvolvimento de front-end**

refere-se ao que o usuário final (também comumente referido como "

**cliente**

") pode ver. Nas formas mais básicas, o desenvolvimento front-end consiste em HTML, CSS e JavaScript.

Como desenvolvedor, você descobrirá que é muito fácil para o seu front-end (site, aplicativo da web, etc.) se tornar muito complexo e ter várias partes móveis diferentes. Isso torna a solução de problemas muito mais difícil quando você precisa passar por um labirinto de código para encontrar o problema. Eventualmente, os desenvolvedores decidiram que deveria haver uma maneira melhor de gerenciar todo esse código, então eles criaram bibliotecas que poderiam tornar a vida mais fácil. **React** era uma dessas bibliotecas.

O React foi criado pelo Facebook e lançado ao público em maio de 2013 e tem sido mantido de forma consistente desde então.

**React**

é uma das bibliotecas JavaScript mais populares para aplicativos da web front-end.

Aqui estão algumas das vantagens do React: Os sites da **Speed** Interactive precisam atualizar o DOM (Document Object Model) cada vez que ocorre uma alteração. Esse processo geralmente é lento e cheio de recursos. Em comparação com outras bibliotecas que manipulam o DOM, o React usa um **DOM virtual** , permitindo atualizar apenas as partes do site que foram alteradas. Isso aumenta drasticamente a velocidade das atualizações, pois os aplicativos da web modernos podem conter milhares de elementos.

Aprenderemos mais sobre o **DOM Virtual** nas próximas lições.

**Facilidade de uso O**

React permite que os desenvolvedores agrupem códigos relacionados, tornando a construção e manutenção de aplicativos em grande escala muito menos complexos.

**O Support** React tem uma comunidade incrivelmente grande e é de código aberto. É mantido pelo Facebook e pela comunidade.

Vamos começar e mergulhar na construção de nosso primeiro aplicativo React!

Adicionando React


Depois de adicionar as tags de script necessárias, podemos começar a construir nosso aplicativo React! Primeiro, precisamos adicionar a biblioteca React como duas tags de script no cabeçalho do nosso documento HTML:

Adicionamos um contêiner, que será usado para exibir algo usando React.
<div id = "container"> </div>
HTML
Você pode usar qualquer id para o seu contêiner. Ele será usado pelo React para localizar o contêiner e adicionar conteúdo a ele.
Agora, é hora de nosso primeiro código React!
Vamos exibir uma mensagem simples como um título:
O código encontra o div do contêiner e adiciona o cabeçalho h1 a ele.
Não se preocupe com a nova sintaxe. Abordaremos isso nas próximas lições.

Estrutura do Projeto


Vamos explorar a estrutura do nosso projeto abrindo-o usando um editor de código.
Estaremos usando o Visual Studio Code em nosso exemplo, mas você está livre para usar qualquer editor de código.contentImageA pasta pública contém arquivos relacionados a como o aplicativo será exibido no cliente, o mais importante deles sendo index.html , que é o modelo HTML de nossa página:contentImageA pasta src contém todos os arquivos JavaScript, CSS e de imagem que será compilado em um arquivo de pacote e injetado em index.html Como o React é compilado em um arquivo de pacote? Ele usa o que é chamado de "carregador de arquivos". No caso de Create React App, Webpack é usado.contentImage

Webpack cria um arquivo "pacote" contendo o conteúdo de vários arquivos que precisam ser "agrupados" e tudo é adicionado em um único arquivo. Em vez de fazer o arquivo HTML procurar vários arquivos, o que pode diminuir o tempo de carregamento tremendamente, ele só precisa encontrar um arquivo.
Lembre-se de que todos os arquivos CSS e JS precisam ser adicionados à pasta src , caso contrário, o webpack não os verá.
Embora existam outros arquivos na pasta src que vêm com Create React App quando ele é gerado, os dois arquivos abaixo são os únicos arquivos críticos:
• index.js : este arquivo é o ponto de entrada em nosso aplicativo. Em nosso código, um método chamado ReactDOM.render () é usado para encontrar um elemento com id = "root" no HTML e adicionar nosso aplicativo React dentro desse elemento (semelhante à lição anterior).
• App.js : este arquivo é o principal componente que será renderizado para o DOM, que atualmente inclui a imagem do logotipo React e o texto padrão, que vemos na saída.
Aprenderemos sobre os componentes nas próximas lições.

# **O que é JSX?**

No módulo anterior, usamos o seguinte código para mostrar uma saída usando React:

ReactDOM.render (
   <h1> Olá, React! </h1>,
   document.getElementById ('root')
 );

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/hello-react-example?file)**

Vamos começar a **[analisar](https://stackblitz.com/edit/hello-react-example?file)** o código e entender cada parte dele. Começaremos com o elemento **<h1> Hello, React! </h1>** . Como você pode ver, o elemento não está entre aspas para representar uma string. É como um elemento HTML, mas o usamos direto no código JavaScript! Isso é chamado de **JSX** e é uma extensão de sintaxe para JavaScript. Isso nos permite construir elementos de interface do usuário diretamente no código JavaScript!

O React não requer o uso de JSX, no entanto, é prática comum na comunidade React usar JSX, pois facilita o desenvolvimento de interfaces de usuário, bem como permite que o React mostre mensagens úteis de erro e aviso.

# **Introdução ao JSX**

Vamos dar uma olhada em nosso código novamente:

ReactDOM.render (
   <h1> Olá, React! </h1>,
   document.getElementById ('root')
 );

**JSX**

O código chama o

método de

**renderização**

do React

e passa dois argumentos, um elemento JSX e um contêiner. O

método

**render**

exibe o elemento fornecido no contêiner, que, em nosso caso, é o elemento HTML com

**id = "root"**

.

**[Experimente no StackBlitz](https://stackblitz.com/edit/hello-react-example?file)**

Quando você chama o método **render** , qualquer conteúdo existente do contêiner é substituído. É por isso que, normalmente, os containers estão vazios no HTML.

Podemos usar qualquer expressão JavaScript dentro de JSX usando chaves.

**Por exemplo:**

nome const = "David";
const el = <p> Olá, **{nome}** </p>;
ReactDOM.render (
   el,
   document.getElementById ('root')
 );

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-jsx-expressions-example?file)**

No exemplo acima, usamos o

**nome**

da variável

no elemento JSX.

Como você pode ver, JSX pode ser usado como expressões JavaScript. Você pode atribuir uma expressão JSX a uma variável, retorná-la de uma função, etc.

# **Atributos em JSX**

Podemos especificar atributos usando aspas, assim como em HTML:

<div **id = "name"** > </div>

**JSX**

Ao usar uma expressão JavaScript como valor de atributos, as aspas não devem ser usadas:

<div **id = {user.id}** > </div>

**JSX**

O React DOM usa a convenção de nomenclatura de propriedade **camelCase** em vez de nomes de atributos HTML.Por exemplo, **class** se torna **className** em JSX.

# **Como funciona o JSX?**

Quando as expressões JSX são compiladas, elas são convertidas em

**objetos**

JavaScript

, representando os elementos React.

O React então usa esses elementos para construir o HTML DOM correspondente e exibi-lo no navegador.

Vamos criar um aplicativo de contador, que incrementa uma variável de contador a cada segundo e a exibe na página como um parágrafo:

deixe contador = 0;
função show () {
   contador ++;
  const el = <p> {contador} </p>;
  ReactDOM.render (
     el, document.getElementById ('root')
   );
}
 setInterval (show, 1000);

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-jsx-counter-example?file)**

Usamos **setInterval** para chamar afunção **show a** cada segundo e renderizar o elemento contador na página. Um dos grandes recursos do React é que ele atualiza apenas os elementos que precisam de uma atualização. Você pode inspecionar a saída HTML do exemplo acima e ver que apenas o texto do parágrafo é atualizado a cada segundo.

Na prática, a maioria dos aplicativos React chama **ReactDOM.render ()** uma vez.Aprenderemos como atualizar elementos sem chamar o método **render** nas próximas lições.

# **DOM Virtual**

Aprendemos na parte anterior que o React atualiza apenas os elementos que são necessários.

Isso permite que os aplicativos React sejam muito mais rápidos do que os aplicativos desenvolvidos com outras tecnologias de front-end.

Mas como o React consegue isso? O React usa um **DOM Virtual** , que é uma representação leve do DOM. Quando um elemento é alterado, ele é primeiro atualizado no Virtual DOM. Esse processo é rápido, pois o DOM virtual é representado por objetos simples. Depois disso, o React compara o DOM virtual ao seu estado anterior e aplica apenas as atualizações do DOM necessárias para trazer o DOM ao estado desejado.

**DOM** significa **D** ocument **O** bject **M** odelo e é uma árvore-como representação da página HTML.Confira nosso **[Tutorial de JavaScript](https://www.sololearn.com/learn/javascript/)** para aprender mais sobre DOM.

# **Componentes**

Os componentes permitem dividir a página em partes independentes e reutilizáveis.

Vamos visualizar isso dando uma olhada em uma parte da página de Discussões do SoloLearn: Observe que a página pode ser dividida em várias partes. Cada uma dessas "partes" é um **componente** . O título é um componente, o botão "nova pergunta" é um componente e a barra de pesquisa é seu próprio componente. Isso torna a organização da página muito mais fácil, mas ainda mais importante, os componentes nos permitem, como desenvolvedores, separar as preocupações umas das outras.

[https://api.sololearn.com/DownloadFile?id=3920](https://api.sololearn.com/DownloadFile?id=3920)

**A separação de interesses** é um princípio de programação que estabelece que cada preocupação deve ser separada em partes individuais.Por exemplo, no diagrama acima, o botão "nova questão" (2) deve ser clicado se um usuário quiser adicionar uma nova questão, enquanto a barra de pesquisa (3) deve ser usada se o usuário quiser pesquisar as questões existentes.

# **Componentes Funcionais**

No React, existem dois tipos de componentes que você pode usar:

**Componentes funcionais**

e

**Componentes de classe**

.

Nesta parte, falaremos sobre componentes funcionais.

Um componente funcional é uma função JavaScript simples:

função Hello () {
   return <h1> Hello world. </h1>;
}

**JSX**

O código acima definiu um componente funcional chamado

**Hello**

, que retorna um elemento React simples.

Observe que o nome do componente funcional começa com uma **letra maiúscula** . Isso é absolutamente crítico. Se iniciarmos o nome de um componente com uma letra minúscula, o navegador tratará nosso componente como um elemento HTML normal em vez de um Componente.

# **Componentes de renderização**

Para exibir o componente, precisamos criar o elemento JSX correspondente.

Por exemplo, para nosso componente definido pelo usuário **Hello** :

const el = <Olá />;

**JSX**

Agora, podemos usar nosso elemento definido pelo usuário e renderizá-lo na página:

função Hello () {
   return <h1> Hello world. </h1>;
}
 const el = <Hello />; 
ReactDOM.render (
   el, 
   document.getElementById ('root')
 );

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-functional-components-example?file)**

Lembre-se de que todos os nomes de componentes precisam começar com uma letra maiúscula.

# **Componentes de classe**

**Os componentes de classe**

são normalmente usados quando há interações do usuário mais avançadas, como formulários e animações.

Todos os componentes da classe precisam estender a classe **React.Component** . Podemos reescrever nosso componente funcional **Hello** como um componente de classe:

class Hello extends React.Component {
   render () {
     return <h1> Hello world. </h1>;
  }
 }

**JSX**

**[Experimente em StackBlitz](https://stackblitz.com/edit/react-class-component-example?file)**

Class Os componentes precisam ter um

método de

**render**

, que é responsável por dizer o que a página deve mostrar.

Aprenderemos sobre os recursos e diferenças dos componentes funcionais e de classe nas próximas lições.

# **Adereços**

Os componentes funcionais podem aceitar argumentos, semelhantes às funções JavaScript. Esses argumentos são chamados de

**adereços**

e representam um objeto.

Por exemplo, podemos usar adereços em nosso componente Hello:

função Hello ( **props** ) {
   return <p> Olá, **{props.name}** ! </p>;
}

**JSX**

Agora, podemos adicionar um

atributo de

**nome**

ao nosso elemento:

const el = <Hello **name = "David"** />;

**JSX**

O valor do atributo será passado para o componente quando renderizado.

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-functional-component-props-example?file)**

Um elemento pode ter vários atributos personalizados, que serão passados para o componente usando o objeto **adereços** . Você pode usar qualquer nome personalizado para seus atributos.

# **Componentes usando componentes**

Os componentes podem usar outros componentes para gerar uma saída.

**Por exemplo:**

function App () {
   return <div>
     <Hello name = "David" />
     <Hello name = "James" />
     <Hello name = "Amy" />
   </div>;
}

**JSX**

Aqui, nosso

componente

**App**

usa o

componente

**Hello**

três vezes, cada vez com um novo

atributo de

**nome**

.

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-functional-component-props-example-2?file)**

Geralmente, é uma boa prática dividir componentes complexos em vários componentes menores, que são reutilizáveis.Por exemplo, um componente **Post** pode usar um componente **Avatar** , um componente **Image** , um componente **Date** , etc.

# **Acessórios em componentes de classe**

Props podem ser acessados em componentes de classe usando

**this.props**

.

**Por exemplo:**

class Hello extends React.Component {
   render () {
     return <p> Hello, { **this.props.name** }! </p>;
  }
 }

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-class-component-props-example?file)**

Uma coisa importante a considerar é que os adereços são somente leitura, o que significa que os componentes não podem modificar seus adereços.

Os aplicativos interativos geralmente precisam alterar os dados e os elementos da página.Aprenderemos como alterar a saída de componentes usando o **estado** na próxima lição.

# **Um exemplo**

Agora que sabemos como criar componentes e passar dados a eles, vamos criar uma lista de compras.

Cada item de nossa lista terá um **nome** e um **preço. Por exemplo:**

<Nome do item = "Queijo" preço = "4,99" />

**JSX**

O

componente

**Item**

renderizará um elemento div simples com os dados:

item de função (props) {
   return <div className = "item">
   <b> Nome: </b> {props.name} <br />
   <b> Preço: </b> {props.price}
   </ div >;
}

**JSX**

Agora podemos usar nosso componente e criar vários itens para nossa lista de compras:

<Item name = "Cheese" price = "4.99" />
 <Item name = "Bread" price = "1.5" />
 <Item name = "Sorvete" price = "24" />

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-shopping-list-example?file)**

Adicionamos alguns estilos CSS simples para separar os itens visualmente.Toque em **Experimentar no StackBlitz** para ver o resultado e brincar com o código.

# **Estado**

Até este ponto, aprendemos como passar dados para componentes usando

**adereços**

.

Muitos aplicativos da web precisam que seus componentes alterem seus dados, por exemplo, após a interação do usuário (clicar em um botão, enviar um formulário, etc.). No entanto, os **adereços** não podem ser alterados. Para permitir que os componentes gerenciem e alterem seus dados, o React fornece um recurso chamado **estado** . **Estado** é um objeto adicionado como uma propriedade nos componentes da classe. **Por exemplo:**

class Hello extends React.Component {
 **state = {
     name: "James"
   }**
   render () {
     return <h1> Hello { **this.state.name** }. </h1>;
  }
 }

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-state-initial-example?file)**

Como você pode ver, o **estado** é apenas um objeto simples, que contém pares chave: valor. Semelhante aos adereços, os valores podem ser acessados usando **this.state** . Agora, quando o componente é renderizado, o estado é inicializado com o valor fornecido e haverá um título que diz "Hello James.". **[Experimente no StackBlitz](https://stackblitz.com/edit/react-state-initial-example?file)**

O objeto de **estado** pode conter vários pares de chave: valor, separados por vírgulas.

# **Estado de mudança**

O estado não deve ser modificado diretamente. Em vez disso, o React fornece um

método

**setState ()**

, que pode ser usado para modificar o estado.

**Por exemplo:**

**this.setState** ({ 
   nome: "James",
   idade: 25
 });

**JSX**

Você precisa passar um objeto com os novos pares chave: valor para o

método

**setState**

.

Por que devemos usar **setState** , em vez de simplesmente alterar os valores das propriedades do objeto diretamente? A resposta revela um dos recursos mais úteis do React: quando **setState** é chamado, o React renderiza automaticamente o componente afetado com o novo estado! Normalmente, a mudança de estado ocorre em manipuladores de eventos. Veremos um exemplo na próxima parte!

Quando o estado muda usando o método **setState** , o React é informado e imediatamente renderiza novamente o componente com o estado atualizado.

# **App de contador**

Para entender melhor como funciona o estado, vamos criar um aplicativo de contador, que incrementa o contador cada vez que um botão é clicado.

Começamos criando nosso

componente

**Contador**

, que inclui o contador e um botão:

class Counter extends React.Component {
   state = {
     counter: 0
   }
   render () {
     return <div>
     <p> {this.state.counter} </p>
     <button> Incremento </button>
     </div>;
  }
 }

**JSX**

Inicializamos nosso

**contador**

com o valor 0 no estado.

Agora, precisamos adicionar um manipulador de eventos de clique ao botão e incrementar o contador no estado. Aqui está o código final:

classe Counter extends React.Component {
   state = {
     counter: 0
   }
   incremento = () => {
 **this.setState ({
      counter: this.state.counter + 1});**   }
   render () {
     return <div>
     <p> {this.state.counter} </p>
     <button **onClick = {this.increment}** > Incrementar </button>
     </div>;
  }
 }

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-state-counter-example?file)**

O evento onClick chama afunção de **incremento** do nosso componente, que usa **setState** para alterar o valor do nosso contador. Quando o estado é alterado, o React dispara automaticamente uma nova renderização do componente. Toque em **Experimentar no StackBlitz** para ver o contador em ação!

Observe que o manipulador de eventos usa a sintaxe camelCase e que a função do manipulador é passada entre chaves.Abordaremos os manipuladores de eventos com mais detalhes nas próximas lições.

# **Adereços vs Estado**

Para recapitular, aqui está um resumo das principais diferenças entre os

**adereços**

e o

**estado**

:

- Usamos **adereçosestadosetState ()setState ()**

    para passar dados aos componentes.

    - Os componentes usam o

    para gerenciar seus dados.

    - Os adereços são somente leitura e não podem ser modificados.
    - O estado pode ser modificado por seu componente usando o

    método

    .

    - O

    método

    resulta em uma nova renderização do componente afetado.

Os componentes que têm estado são chamados de **stateful** , enquanto os componentes que não usam state são chamados de **stateless** .

# **Ganchos**

A versão anterior do React permitia o uso de estado apenas com componentes de classe.

Em iterações recentes do React, um novo recurso chamado

**hooks**

foi introduzido, permitindo usar o estado dentro de componentes funcionais.

Primeiro, precisamos importar o gancho **useState** :

import React, **{useState}** de ' **react** ';

**JSX**

**useState**

retorna um par, o valor do estado atual e uma função, que permite alterar o estado.

**useState**

recebe um argumento, que é o valor inicial do estado.

Vejamos um exemplo:

função Hello () {
 **const [name, setName] = useState ("David");**   return <h1> Hello {name}. </h1>;
}

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-hooks-initial-example?file)**

No exemplo acima, criamos umavariável de estado de **nome** e umafunção **setName** . A sintaxe dos colchetes é chamada de **desestruturação da matriz** . Ele atribui avariável **name** ao valor do estado atual e **setName** à função que permite alterar o estado. Você pode nomear essas variáveis como quiser. Em seguida, passamos "David" como o valor inicial para nossa variável de nome para **useState ()** .

Você pode criar várias variáveis de estado com seus métodos de conjunto correspondentes. Basta usar instruções separadas para cada variável usando o gancho useState.

# **App de contador usando ganchos**

Agora podemos reescrever nosso aplicativo Counter da lição anterior usando um componente funcional e ganchos!

**Aqui está o código:**

função Counter () {
   const [contador, setCounter] = useState (0);
  incremento de função () {
     setContador (contador + 1);
  }
   return <div>
   <p> {counter} </p>
   <button onClick = {incremento}>
     Incremento
   </button>
   </div>;
}

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-hooks-counter-example?file)**

Como você pode ver, em comparação com o componente da classe, o código é muito mais curto e fácil de ler e entender. Essa foi uma das razões pelas quais a equipe React criou os Hooks.

Lembre-se de que os ganchos só podem ser usados dentro de componentes funcionais.Ganchos são funções que permitem "enganchar" recursos do React a partir de componentes de função.

# **Métodos de Ciclo de Vida**

O React fornece métodos de ciclo de vida especiais para componentes de classe, que são chamados quando os componentes são montados, atualizados ou desmontados.

**A montagem** é o processo em que um componente é renderizado na página. **A desmontagem** é o processo em que um componente é removido da página. O método **componentDidMount** é chamado quando um componente é renderizado na página. Por exemplo, podemos usar **componentDidMount** em nosso aplicativo Contador para definir o valor inicial do contador:

componentDidMount () {
   this.setState ({contador: 42});
}

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-state-counter-mount-example?file)**

Isso definirá um valor inicial do contador quando o componente for renderizado. **componentDidMount** é normalmente usado para preencher o estado dentro de um componente quando ele é inicialmente montado no DOM.

Da mesma forma, o método de ciclo de vida **componentWillUnmount ()** é chamado logo antes de o componente ser removido do DOM. Ele pode ser usado para liberar recursos utilizados pelo componente.
