# **O que é desenvolvimento front-end?**

**O desenvolvimento de front-end**

refere-se ao que o usuário final (também comumente referido como "

**cliente**

") pode ver. Nas formas mais básicas, o desenvolvimento front-end consiste em HTML, CSS e JavaScript.

Como desenvolvedor, você descobrirá que é muito fácil para o seu front-end (site, aplicativo da web, etc.) se tornar muito complexo e ter várias partes móveis diferentes. Isso torna a solução de problemas muito mais difícil quando você precisa passar por um labirinto de código para encontrar o problema. Eventualmente, os desenvolvedores decidiram que deveria haver uma maneira melhor de gerenciar todo esse código, então eles criaram bibliotecas que poderiam tornar a vida mais fácil. **React** era uma dessas bibliotecas.

O React foi criado pelo Facebook e lançado ao público em maio de 2013 e tem sido mantido de forma consistente desde então.

**React**

é uma das bibliotecas JavaScript mais populares para aplicativos da web front-end.

Aqui estão algumas das vantagens do React: Os sites da **Speed** Interactive precisam atualizar o DOM (Document Object Model) cada vez que ocorre uma alteração. Esse processo geralmente é lento e cheio de recursos. Em comparação com outras bibliotecas que manipulam o DOM, o React usa um **DOM virtual** , permitindo atualizar apenas as partes do site que foram alteradas. Isso aumenta drasticamente a velocidade das atualizações, pois os aplicativos da web modernos podem conter milhares de elementos.

Aprenderemos mais sobre o **DOM Virtual** nas próximas lições.

**Facilidade de uso O**

React permite que os desenvolvedores agrupem códigos relacionados, tornando a construção e manutenção de aplicativos em grande escala muito menos complexos.

**O Support** React tem uma comunidade incrivelmente grande e é de código aberto. É mantido pelo Facebook e pela comunidade.

Vamos começar e mergulhar na construção de nosso primeiro aplicativo React!

Adicionando React


Depois de adicionar as tags de script necessárias, podemos começar a construir nosso aplicativo React! Primeiro, precisamos adicionar a biblioteca React como duas tags de script no cabeçalho do nosso documento HTML:

Adicionamos um contêiner, que será usado para exibir algo usando React.
<div id = "container"> </div>
HTML
Você pode usar qualquer id para o seu contêiner. Ele será usado pelo React para localizar o contêiner e adicionar conteúdo a ele.
Agora, é hora de nosso primeiro código React!
Vamos exibir uma mensagem simples como um título:
O código encontra o div do contêiner e adiciona o cabeçalho h1 a ele.
Não se preocupe com a nova sintaxe. Abordaremos isso nas próximas lições.

Estrutura do Projeto


Vamos explorar a estrutura do nosso projeto abrindo-o usando um editor de código.
Estaremos usando o Visual Studio Code em nosso exemplo, mas você está livre para usar qualquer editor de código.contentImageA pasta pública contém arquivos relacionados a como o aplicativo será exibido no cliente, o mais importante deles sendo index.html , que é o modelo HTML de nossa página:contentImageA pasta src contém todos os arquivos JavaScript, CSS e de imagem que será compilado em um arquivo de pacote e injetado em index.html Como o React é compilado em um arquivo de pacote? Ele usa o que é chamado de "carregador de arquivos". No caso de Create React App, Webpack é usado.contentImage

Webpack cria um arquivo "pacote" contendo o conteúdo de vários arquivos que precisam ser "agrupados" e tudo é adicionado em um único arquivo. Em vez de fazer o arquivo HTML procurar vários arquivos, o que pode diminuir o tempo de carregamento tremendamente, ele só precisa encontrar um arquivo.
Lembre-se de que todos os arquivos CSS e JS precisam ser adicionados à pasta src , caso contrário, o webpack não os verá.
Embora existam outros arquivos na pasta src que vêm com Create React App quando ele é gerado, os dois arquivos abaixo são os únicos arquivos críticos:
• index.js : este arquivo é o ponto de entrada em nosso aplicativo. Em nosso código, um método chamado ReactDOM.render () é usado para encontrar um elemento com id = "root" no HTML e adicionar nosso aplicativo React dentro desse elemento (semelhante à lição anterior).
• App.js : este arquivo é o principal componente que será renderizado para o DOM, que atualmente inclui a imagem do logotipo React e o texto padrão, que vemos na saída.
Aprenderemos sobre os componentes nas próximas lições.

# **O que é JSX?**

No módulo anterior, usamos o seguinte código para mostrar uma saída usando React:

ReactDOM.render (
   <h1> Olá, React! </h1>,
   document.getElementById ('root')
 );

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/hello-react-example?file)**

Vamos começar a **[analisar](https://stackblitz.com/edit/hello-react-example?file)** o código e entender cada parte dele. Começaremos com o elemento **<h1> Hello, React! </h1>** . Como você pode ver, o elemento não está entre aspas para representar uma string. É como um elemento HTML, mas o usamos direto no código JavaScript! Isso é chamado de **JSX** e é uma extensão de sintaxe para JavaScript. Isso nos permite construir elementos de interface do usuário diretamente no código JavaScript!

O React não requer o uso de JSX, no entanto, é prática comum na comunidade React usar JSX, pois facilita o desenvolvimento de interfaces de usuário, bem como permite que o React mostre mensagens úteis de erro e aviso.

# **Introdução ao JSX**

Vamos dar uma olhada em nosso código novamente:

ReactDOM.render (
   <h1> Olá, React! </h1>,
   document.getElementById ('root')
 );

**JSX**

O código chama o

método de

**renderização**

do React

e passa dois argumentos, um elemento JSX e um contêiner. O

método

**render**

exibe o elemento fornecido no contêiner, que, em nosso caso, é o elemento HTML com

**id = "root"**

.

**[Experimente no StackBlitz](https://stackblitz.com/edit/hello-react-example?file)**

Quando você chama o método **render** , qualquer conteúdo existente do contêiner é substituído. É por isso que, normalmente, os containers estão vazios no HTML.

Podemos usar qualquer expressão JavaScript dentro de JSX usando chaves.

**Por exemplo:**

nome const = "David";
const el = <p> Olá, **{nome}** </p>;
ReactDOM.render (
   el,
   document.getElementById ('root')
 );

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-jsx-expressions-example?file)**

No exemplo acima, usamos o

**nome**

da variável

no elemento JSX.

Como você pode ver, JSX pode ser usado como expressões JavaScript. Você pode atribuir uma expressão JSX a uma variável, retorná-la de uma função, etc.

# **Atributos em JSX**

Podemos especificar atributos usando aspas, assim como em HTML:

<div **id = "name"** > </div>

**JSX**

Ao usar uma expressão JavaScript como valor de atributos, as aspas não devem ser usadas:

<div **id = {user.id}** > </div>

**JSX**

O React DOM usa a convenção de nomenclatura de propriedade **camelCase** em vez de nomes de atributos HTML.Por exemplo, **class** se torna **className** em JSX.

# **Como funciona o JSX?**

Quando as expressões JSX são compiladas, elas são convertidas em

**objetos**

JavaScript

, representando os elementos React.

O React então usa esses elementos para construir o HTML DOM correspondente e exibi-lo no navegador.

Vamos criar um aplicativo de contador, que incrementa uma variável de contador a cada segundo e a exibe na página como um parágrafo:

deixe contador = 0;
função show () {
   contador ++;
  const el = <p> {contador} </p>;
  ReactDOM.render (
     el, document.getElementById ('root')
   );
}
 setInterval (show, 1000);

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-jsx-counter-example?file)**

Usamos **setInterval** para chamar afunção **show a** cada segundo e renderizar o elemento contador na página. Um dos grandes recursos do React é que ele atualiza apenas os elementos que precisam de uma atualização. Você pode inspecionar a saída HTML do exemplo acima e ver que apenas o texto do parágrafo é atualizado a cada segundo.

Na prática, a maioria dos aplicativos React chama **ReactDOM.render ()** uma vez.Aprenderemos como atualizar elementos sem chamar o método **render** nas próximas lições.

# **DOM Virtual**

Aprendemos na parte anterior que o React atualiza apenas os elementos que são necessários.

Isso permite que os aplicativos React sejam muito mais rápidos do que os aplicativos desenvolvidos com outras tecnologias de front-end.

Mas como o React consegue isso? O React usa um **DOM Virtual** , que é uma representação leve do DOM. Quando um elemento é alterado, ele é primeiro atualizado no Virtual DOM. Esse processo é rápido, pois o DOM virtual é representado por objetos simples. Depois disso, o React compara o DOM virtual ao seu estado anterior e aplica apenas as atualizações do DOM necessárias para trazer o DOM ao estado desejado.

**DOM** significa **D** ocument **O** bject **M** odelo e é uma árvore-como representação da página HTML.Confira nosso **[Tutorial de JavaScript](https://www.sololearn.com/learn/javascript/)** para aprender mais sobre DOM.

# **Componentes**

Os componentes permitem dividir a página em partes independentes e reutilizáveis.

Vamos visualizar isso dando uma olhada em uma parte da página de Discussões do SoloLearn: Observe que a página pode ser dividida em várias partes. Cada uma dessas "partes" é um **componente** . O título é um componente, o botão "nova pergunta" é um componente e a barra de pesquisa é seu próprio componente. Isso torna a organização da página muito mais fácil, mas ainda mais importante, os componentes nos permitem, como desenvolvedores, separar as preocupações umas das outras.

[https://api.sololearn.com/DownloadFile?id=3920](https://api.sololearn.com/DownloadFile?id=3920)

**A separação de interesses** é um princípio de programação que estabelece que cada preocupação deve ser separada em partes individuais.Por exemplo, no diagrama acima, o botão "nova questão" (2) deve ser clicado se um usuário quiser adicionar uma nova questão, enquanto a barra de pesquisa (3) deve ser usada se o usuário quiser pesquisar as questões existentes.

# **Componentes Funcionais**

No React, existem dois tipos de componentes que você pode usar:

**Componentes funcionais**

e

**Componentes de classe**

.

Nesta parte, falaremos sobre componentes funcionais.

Um componente funcional é uma função JavaScript simples:

função Hello () {
   return <h1> Hello world. </h1>;
}

**JSX**

O código acima definiu um componente funcional chamado

**Hello**

, que retorna um elemento React simples.

Observe que o nome do componente funcional começa com uma **letra maiúscula** . Isso é absolutamente crítico. Se iniciarmos o nome de um componente com uma letra minúscula, o navegador tratará nosso componente como um elemento HTML normal em vez de um Componente.

# **Componentes de renderização**

Para exibir o componente, precisamos criar o elemento JSX correspondente.

Por exemplo, para nosso componente definido pelo usuário **Hello** :

const el = <Olá />;

**JSX**

Agora, podemos usar nosso elemento definido pelo usuário e renderizá-lo na página:

função Hello () {
   return <h1> Hello world. </h1>;
}
 const el = <Hello />; 
ReactDOM.render (
   el, 
   document.getElementById ('root')
 );

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-functional-components-example?file)**

Lembre-se de que todos os nomes de componentes precisam começar com uma letra maiúscula.

# **Componentes de classe**

**Os componentes de classe**

são normalmente usados quando há interações do usuário mais avançadas, como formulários e animações.

Todos os componentes da classe precisam estender a classe **React.Component** . Podemos reescrever nosso componente funcional **Hello** como um componente de classe:

class Hello extends React.Component {
   render () {
     return <h1> Hello world. </h1>;
  }
 }

**JSX**

**[Experimente em StackBlitz](https://stackblitz.com/edit/react-class-component-example?file)**

Class Os componentes precisam ter um

método de

**render**

, que é responsável por dizer o que a página deve mostrar.

Aprenderemos sobre os recursos e diferenças dos componentes funcionais e de classe nas próximas lições.

# **Adereços**

Os componentes funcionais podem aceitar argumentos, semelhantes às funções JavaScript. Esses argumentos são chamados de

**adereços**

e representam um objeto.

Por exemplo, podemos usar adereços em nosso componente Hello:

função Hello ( **props** ) {
   return <p> Olá, **{props.name}** ! </p>;
}

**JSX**

Agora, podemos adicionar um

atributo de

**nome**

ao nosso elemento:

const el = <Hello **name = "David"** />;

**JSX**

O valor do atributo será passado para o componente quando renderizado.

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-functional-component-props-example?file)**

Um elemento pode ter vários atributos personalizados, que serão passados para o componente usando o objeto **adereços** . Você pode usar qualquer nome personalizado para seus atributos.

# **Componentes usando componentes**

Os componentes podem usar outros componentes para gerar uma saída.

**Por exemplo:**

function App () {
   return <div>
     <Hello name = "David" />
     <Hello name = "James" />
     <Hello name = "Amy" />
   </div>;
}

**JSX**

Aqui, nosso

componente

**App**

usa o

componente

**Hello**

três vezes, cada vez com um novo

atributo de

**nome**

.

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-functional-component-props-example-2?file)**

Geralmente, é uma boa prática dividir componentes complexos em vários componentes menores, que são reutilizáveis.Por exemplo, um componente **Post** pode usar um componente **Avatar** , um componente **Image** , um componente **Date** , etc.

# **Acessórios em componentes de classe**

Props podem ser acessados em componentes de classe usando

**this.props**

.

**Por exemplo:**

class Hello extends React.Component {
   render () {
     return <p> Hello, { **this.props.name** }! </p>;
  }
 }

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-class-component-props-example?file)**

Uma coisa importante a considerar é que os adereços são somente leitura, o que significa que os componentes não podem modificar seus adereços.

Os aplicativos interativos geralmente precisam alterar os dados e os elementos da página.Aprenderemos como alterar a saída de componentes usando o **estado** na próxima lição.

# **Um exemplo**

Agora que sabemos como criar componentes e passar dados a eles, vamos criar uma lista de compras.

Cada item de nossa lista terá um **nome** e um **preço. Por exemplo:**

<Nome do item = "Queijo" preço = "4,99" />

**JSX**

O

componente

**Item**

renderizará um elemento div simples com os dados:

item de função (props) {
   return <div className = "item">
   <b> Nome: </b> {props.name} <br />
   <b> Preço: </b> {props.price}
   </ div >;
}

**JSX**

Agora podemos usar nosso componente e criar vários itens para nossa lista de compras:

<Item name = "Cheese" price = "4.99" />
 <Item name = "Bread" price = "1.5" />
 <Item name = "Sorvete" price = "24" />

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-shopping-list-example?file)**

Adicionamos alguns estilos CSS simples para separar os itens visualmente.Toque em **Experimentar no StackBlitz** para ver o resultado e brincar com o código.

# **Estado**

Até este ponto, aprendemos como passar dados para componentes usando

**adereços**

.

Muitos aplicativos da web precisam que seus componentes alterem seus dados, por exemplo, após a interação do usuário (clicar em um botão, enviar um formulário, etc.). No entanto, os **adereços** não podem ser alterados. Para permitir que os componentes gerenciem e alterem seus dados, o React fornece um recurso chamado **estado** . **Estado** é um objeto adicionado como uma propriedade nos componentes da classe. **Por exemplo:**

class Hello extends React.Component {
 **state = {
     name: "James"
   }**
   render () {
     return <h1> Hello { **this.state.name** }. </h1>;
  }
 }

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-state-initial-example?file)**

Como você pode ver, o **estado** é apenas um objeto simples, que contém pares chave: valor. Semelhante aos adereços, os valores podem ser acessados usando **this.state** . Agora, quando o componente é renderizado, o estado é inicializado com o valor fornecido e haverá um título que diz "Hello James.". **[Experimente no StackBlitz](https://stackblitz.com/edit/react-state-initial-example?file)**

O objeto de **estado** pode conter vários pares de chave: valor, separados por vírgulas.

# **Estado de mudança**

O estado não deve ser modificado diretamente. Em vez disso, o React fornece um

método

**setState ()**

, que pode ser usado para modificar o estado.

**Por exemplo:**

**this.setState** ({ 
   nome: "James",
   idade: 25
 });

**JSX**

Você precisa passar um objeto com os novos pares chave: valor para o

método

**setState**

.

Por que devemos usar **setState** , em vez de simplesmente alterar os valores das propriedades do objeto diretamente? A resposta revela um dos recursos mais úteis do React: quando **setState** é chamado, o React renderiza automaticamente o componente afetado com o novo estado! Normalmente, a mudança de estado ocorre em manipuladores de eventos. Veremos um exemplo na próxima parte!

Quando o estado muda usando o método **setState** , o React é informado e imediatamente renderiza novamente o componente com o estado atualizado.

# **App de contador**

Para entender melhor como funciona o estado, vamos criar um aplicativo de contador, que incrementa o contador cada vez que um botão é clicado.

Começamos criando nosso

componente

**Contador**

, que inclui o contador e um botão:

class Counter extends React.Component {
   state = {
     counter: 0
   }
   render () {
     return <div>
     <p> {this.state.counter} </p>
     <button> Incremento </button>
     </div>;
  }
 }

**JSX**

Inicializamos nosso

**contador**

com o valor 0 no estado.

Agora, precisamos adicionar um manipulador de eventos de clique ao botão e incrementar o contador no estado. Aqui está o código final:

classe Counter extends React.Component {
   state = {
     counter: 0
   }
   incremento = () => {
 **this.setState ({
      counter: this.state.counter + 1});**   }
   render () {
     return <div>
     <p> {this.state.counter} </p>
     <button **onClick = {this.increment}** > Incrementar </button>
     </div>;
  }
 }

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-state-counter-example?file)**

O evento onClick chama afunção de **incremento** do nosso componente, que usa **setState** para alterar o valor do nosso contador. Quando o estado é alterado, o React dispara automaticamente uma nova renderização do componente. Toque em **Experimentar no StackBlitz** para ver o contador em ação!

Observe que o manipulador de eventos usa a sintaxe camelCase e que a função do manipulador é passada entre chaves.Abordaremos os manipuladores de eventos com mais detalhes nas próximas lições.

# **Adereços vs Estado**

Para recapitular, aqui está um resumo das principais diferenças entre os

**adereços**

e o

**estado**

:

- Usamos **adereçosestadosetState ()setState ()**

    para passar dados aos componentes.

    - Os componentes usam o

    para gerenciar seus dados.

    - Os adereços são somente leitura e não podem ser modificados.
    - O estado pode ser modificado por seu componente usando o

    método

    .

    - O

    método

    resulta em uma nova renderização do componente afetado.

Os componentes que têm estado são chamados de **stateful** , enquanto os componentes que não usam state são chamados de **stateless** .

# **Ganchos**

A versão anterior do React permitia o uso de estado apenas com componentes de classe.

Em iterações recentes do React, um novo recurso chamado

**hooks**

foi introduzido, permitindo usar o estado dentro de componentes funcionais.

Primeiro, precisamos importar o gancho **useState** :

import React, **{useState}** de ' **react** ';

**JSX**

**useState**

retorna um par, o valor do estado atual e uma função, que permite alterar o estado.

**useState**

recebe um argumento, que é o valor inicial do estado.

Vejamos um exemplo:

função Hello () {
 **const [name, setName] = useState ("David");**   return <h1> Hello {name}. </h1>;
}

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-hooks-initial-example?file)**

No exemplo acima, criamos umavariável de estado de **nome** e umafunção **setName** . A sintaxe dos colchetes é chamada de **desestruturação da matriz** . Ele atribui avariável **name** ao valor do estado atual e **setName** à função que permite alterar o estado. Você pode nomear essas variáveis como quiser. Em seguida, passamos "David" como o valor inicial para nossa variável de nome para **useState ()** .

Você pode criar várias variáveis de estado com seus métodos de conjunto correspondentes. Basta usar instruções separadas para cada variável usando o gancho useState.

# **App de contador usando ganchos**

Agora podemos reescrever nosso aplicativo Counter da lição anterior usando um componente funcional e ganchos!

**Aqui está o código:**

função Counter () {
   const [contador, setCounter] = useState (0);
  incremento de função () {
     setContador (contador + 1);
  }
   return <div>
   <p> {counter} </p>
   <button onClick = {incremento}>
     Incremento
   </button>
   </div>;
}

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-hooks-counter-example?file)**

Como você pode ver, em comparação com o componente da classe, o código é muito mais curto e fácil de ler e entender. Essa foi uma das razões pelas quais a equipe React criou os Hooks.

Lembre-se de que os ganchos só podem ser usados dentro de componentes funcionais.Ganchos são funções que permitem "enganchar" recursos do React a partir de componentes de função.

# **Métodos de Ciclo de Vida**

O React fornece métodos de ciclo de vida especiais para componentes de classe, que são chamados quando os componentes são montados, atualizados ou desmontados.

**A montagem** é o processo em que um componente é renderizado na página. **A desmontagem** é o processo em que um componente é removido da página. O método **componentDidMount** é chamado quando um componente é renderizado na página. Por exemplo, podemos usar **componentDidMount** em nosso aplicativo Contador para definir o valor inicial do contador:

componentDidMount () {
   this.setState ({contador: 42});
}

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-state-counter-mount-example?file)**

Isso definirá um valor inicial do contador quando o componente for renderizado. **componentDidMount** é normalmente usado para preencher o estado dentro de um componente quando ele é inicialmente montado no DOM.

Da mesma forma, o método de ciclo de vida **componentWillUnmount ()** é chamado logo antes de o componente ser removido do DOM. Ele pode ser usado para liberar recursos utilizados pelo componente.

# **componentDidUpdate**

Outro método de ciclo de vida é

**componentDidUpdate ()**

, que é chamado quando um componente é atualizado no DOM.

Podemos, por exemplo, alertar o valor do contador atual quando ele é incrementado:

componentDidUpdate () {
   alert ("Número de cliques:" + this.state.counter);
}

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-state-counter-update-example?file)**

**componentDidUpdate ()** só é chamado quando o componente é atualizado.

Bom trabalho!

# **Manipulação de eventos**

O tratamento de eventos no React é muito semelhante ao tratamento de eventos no DOM.

A única diferença é que os nomes dos eventos usam a sintaxe camelCase e o manipulador de eventos precisa ser passado entre chaves. **Por exemplo, para lidar com o evento de clique em um botão:**

<button **onClick = {handleClick}** >
   Meu botão
 </button>

**JSX**

Clicar no botão irá chamar a

função

**handleClick**

do componente.

**Vamos explorar nosso aplicativo Counter:**

função Counter () {
   const [contador, setCounter] = useState (0);
  incremento de função () {
     setContador (contador + 1);
  }
   return <div>
   <p> {counter} </p>
   <button **onClick = {incremento}** > Incremento </button>
   </div>;
}

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-hooks-counter-example?file)**

Oevento **onClick** chama afunção de **incremento** , que está incrementando a variável de estado do contador.

Confira o mesmo aplicativo Counter desenvolvido usando um componente de classe **[aqui](https://stackblitz.com/edit/react-state-counter-example?file)** .

# **Manipulação de entrada do usuário**

Uma das maneiras comuns de os usuários interagirem com as páginas da web é por meio de campos de texto.

Podemos lidar com a entrada do usuário no React usando o evento **onChange** do campo de texto. Quando o valor do campo de texto muda, o manipulador de eventos é chamado, atualizando o valor do campo no estado do componente. Dessa forma, você sempre tem o valor real do campo de texto no estado. Vamos fazer um aplicativo para converter Km em Milhas. Pegaremos o valor Km de um campo de texto e calcularemos o valor das milhas após a entrada:

função Converter () {
   const [km, setKm] = useState (0);

  função handleChange (e) {
     setKm (e.target.value);
  }
   função convert (km) {
     return (km / 1,609) .toFixed (2);
  }
   return <div>
   <input type = "text" value = {km}
 **onChange = {handleChange}** />
   <p> {km} km é {convert (km)} milhas </p>
   </div>;
}

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-km-miles-converter?file)**

Nosso componente Converter inclui um campo de texto, que chama afunção **handleChange** quando seu valor muda. A função handleChange atualiza o estado com o valor atual do campo de texto, fazendo com que o componente seja novamente renderizado e mostre o valor de milhas correspondente, que é calculado usando afunção **converter** .

O valor do campo de texto é acessado por meio do objeto **e** , que representa o evento React. Ele é passado para a função de manipulador de eventos como um argumento e pode ser usado para acessar o objeto de evento.

# **Formulários**

Na parte anterior, aprendemos como lidar com a entrada do usuário em campos de texto. Os campos de texto geralmente fazem parte de um formulário.

Semelhante ao exemplo anterior, os elementos do formulário React mantêm seu estado e o atualizam com base na entrada do usuário. Assim você sempre terá os dados do seu formulário à sua disposição no estado. Para demonstrar isso, criaremos um formulário, que adicionará números toda vez que o formulário for enviado e exibirá a soma. Nosso formulário contém um campo de entrada e um botão de envio:

função AddForm () {
   const [sum, setSum] = useState (0);
  const [num, setNum] = useState (0);
  função handleChange (e) {
     setNum (e.target.value);
  }
   function handleSubmit (e) {
     setSum (sum + Number (num));
    e.preventDefault ();
  }
   return <form **onSubmit = {handleSubmit}** >
   <input type = "number" value = {num} o**nChange = {handleChange}** />
   <input type = "submit" value = "Add" />
   <p> A soma é { soma } </p>
   </form>;
}

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-simple-calc-form-example?file)**

No código acima, o valor da entrada é controlado pelo React (mantemos o valor no estado). Quando o formulário é enviado usando o botão de envio, a função **handleSubmit** é chamada, o que atualiza o valor de **sum** no estado. Um elemento de formulário de entrada cujo valor é controlado pelo React dessa forma é chamado de " **componente controlado** ".

Observe o **e.preventDefault ();** demonstração. Essa instrução evita o comportamento padrão do formulário, que, por padrão, recarrega a página quando é enviado. Em JavaScript, usaríamos **return false;** para isso, mas no React precisamos chamar **preventDefault ()** .

# **Listas**

Os aplicativos da Web geralmente contêm elementos repetidos, como listas ou seções, em que o mesmo elemento DOM é repetido com um conjunto de dados diferente.

Considere uma matriz de strings:

const arr = ["A", "B", "C"];

**JSX**

Precisamos renderizar um elemento de lista <li> para cada item do array.

Podemos definir um

componente

**MyList**

e passá-lo a matriz como um prop usando um

atributo de

**dados**

personalizado

:

<Dados MyList = {arr} />

**JSX**

Agora, quando a matriz está acessível por meio de adereços, podemos escrever a lógica do componente:

função MyList (props) {
   const arr = props.data;
  const listItems = arr.map ((val) =>
     <li> {val} </li>
   );
  return <ul> {listItems} </ul>;
}

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-simple-list-example?file)**

Pegamos a matriz de entrada dos adereços de entrada, percorremos a matriz usando afunção de **mapa** JavaScripte retornamos um elemento <li> para cada item. O array resultante é armazenado navariável **listItems** . Em seguida, o componente retorna o array listItems dentro de uma tag <ul>. **O resultado:**

[https://api.sololearn.com/DownloadFile?id=4435](https://api.sololearn.com/DownloadFile?id=4435)

Esse código resulta em um aviso, dizendo que cada elemento precisa de uma **chave** exclusiva . Veremos as **chaves** na próxima parte.

Chaves


Cada elemento em uma lista deve ter um atributo- chave .
As chaves atuam como uma identidade única, identificando cada elemento.
Normalmente, são IDs de seus dados ou podem ser índices gerados automaticamente. Por exemplo:

const listItems = arr.map ((val, index) =>
 
  <li key = {index} > {val} </li>
 
);
JSX
Experimente no StackBlitz
As chaves são importantes porque identificam os elementos de maneira única, ajudando o React a entender quais itens foram alterados, adicionados ou removidos.

# **Gerente de contato**

Agora que sabemos como criar componentes, passar dados para eles usando props e gerenciar seus dados usando estado, vamos começar a construir nosso

**Contact Manager**

.

Nosso Contact Manager permitirá visualizar a lista de contatos e adicionar novos à lista. Olhando para a maquete, faz sentido ter dois componentes: **AddPersonForm** : um formulário com o campo de texto e o botão Adicionar. **PeopleList** : uma lista de contatos. Vamos criar esses componentes. **AddPersonForm** usa o estado para gerenciar o valor do campo de texto:

[https://api.sololearn.com/DownloadFile?id=4390](https://api.sololearn.com/DownloadFile?id=4390)

function AddPersonForm () {
   const [person, setPerson] = useState ("");
  função handleChange (e) {
     setPerson (e.target.value);
  }
   function handleSubmit (e) {
     e.preventDefault ();
  }
   return (
     <form onSubmit = {handleSubmit}>
     <input type = "text" 
     placeholder = "Adicionar novo contato" 
     onChange = {handleChange} 
     value = {person} />
     <button type = "submit"> Adicionar </button>
     </form>
     );
}

**JSX**

Por enquanto, apenas evitamos o comportamento padrão quando o formulário é enviado.

**PeopleList** recebeu uma matriz que representa os contatos e renderiza uma lista na página:

função PeopleList (adereços) {
   const arr = props.data;
  const listItems = arr.map ((val, index) =>
     <li key = {index}> {val} </li>
   );
  return <ul> {listItems} </ul>;
}

**JSX**

Agora podemos renderizar nossos componentes na página e incluir alguns dados iniciais:

contatos const = ["James Smith", "Thomas Anderson", "Bruce Wayne"];
const el = (
   <div>
     <AddPersonForm />
     <PeopleList data = {contacts} />
   </div>
 );

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-contact-manager-1?file)**

Toque em **Experimente no StackBlitz** para ver o resultado.

Adicionar um novo contato não funciona, pois ainda não construímos a lógica na função **handleSubmit** .

# **Estado de Compartilhamento**

No momento, nosso

**AddPersonForm**

mantém seu estado de forma independente. Como podemos adicionar um novo contato à nossa

**PeopleList**

então, quando o formulário for enviado?

Para fazer isso, precisamos compartilhar o estado entre os componentes. Podemos fazer isso **elevando o estado** a um componente pai. Isso significa que o componente pai conterá os dados que precisam ser compartilhados entre os componentes. No nosso caso, é a lista de contatos. Vamos criar um componente pai chamado **ContactManager** , que inclui **AddPersonForm** e **PeopleList** como componentes filho e mantém a lista de contatos em seu estado:

função ContactManager (props) {
   const [contacts, setContacts] = useState (props.data);
  return (
     <div>
       <AddPersonForm />
       <PeopleList data = {contacts} />
     </div>
   );
}

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-contact-manager-2?file)**

O componente ContactManager recebe a lista de contatos inicial usando props, salva-a em seu estado. Em seguida, ele passa a lista de contatos para seu componente filho.

Os dados podem ser passados do pai para o filho, mas não do filho para o pai. O React usa o que é chamado de **fluxo de dados unidirecional** , em outras palavras, os dados fluem apenas para baixo, por assim dizer.

# **Adicionar um contato**

Agora, podemos criar uma

função

**addPerson ()**

para nosso componente ContactManager para adicionar uma nova pessoa à nossa matriz de estado de contatos:

função ContactManager (props) {
   const [contacts, setContacts] = useState (props.data);
**função addPerson (nome) {
     setContacts ([... contatos, nome]);
  }** ...
 }

**JSX**

Mas como vamos chamar essa função de nosso componente filho AddPersonForm, onde os dados da nova pessoa são armazenados?

Assim como passamos dados usando adereços, o React nos permite passar referências de função!

função ContactManager (props) {
   const [contacts, setContacts] = useState (props.data);
  função addPerson (nome) {
     setContacts ([... contatos, nome]);
  }
   return (
     <div>
       <AddPersonForm **handleSubmit = {addPerson}** />
       <PeopleList data = {contacts} />
     </div>
   );
}

**JSX**

Semelhante a passar a lista de contatos para nosso componente PeopleList, passamos a

função

**addPerson**

() para nosso AddPersonForm usando um prop chamado

**handleSubmit**

.

Agora, nossa PeopleList pode chamar a função **handleSubmit** que recebeu quando o formulário foi enviado, para adicionar uma nova pessoa à lista:

function AddPersonForm (props) {
   const [person, setPerson] = useState ('');
  função handleChange (e) {
     setPerson (e.target.value);
  }
 **function handleSubmit (e) {
     props.handleSubmit (pessoa);
    setPerson ('');
    e.preventDefault ();
  }**   return (
     <form onSubmit = {handleSubmit}>
       <input type = "text" 
         placeholder = "Adicionar novo contato" 
         onChange = {handleChange} 
         value = {person} />
       <button type = "submit"> Adicionar </button>
     </form>
   );
}

**JSX**

**[Experimente no StackBlitz](https://stackblitz.com/edit/react-contact-manager-3?file)**

Também **limpamos** o valor do campo de texto usando **setPerson ('')** após adicionar uma nova pessoa.
